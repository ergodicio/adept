---
id: a-24d8
status: open
deps: []
links: []
created: 2026-01-08T17:02:10Z
type: epic
priority: 0
assignee: Jack Coughlin
---
# Multi-Species Support for _vlasov1d

Add support for multiple species (electrons, ions, etc.) to the _vlasov1d module.

## Design

Currently, the code:
- Tracks a single electron distribution function `f[nx, nv]`
- Implicitly assumes q/m = -1 (electron units) throughout
- Allows multiple "species-*" contributions under `density:`, but these all represent different electron populations that get summed into one distribution

The goal is to:
- Track **separate distribution functions** for each species: `{name: f_s[nx, nv]}`
- Support **arbitrary charge-to-mass ratios** (q/m) for each species
- Enable **electron-ion physics** (e.g., Vlasov-Poisson with mobile ions)
- Maintain **backward compatibility** with existing single-species simulations
- Keep the **pytree-friendly structure** for JAX operations


### Configuration Schema Changes

#### Current Structure (what we keep):
```yaml
density:
  quasineutrality: true
  species-background:    # These remain electron population components
    v0: 0.0
    T0: 1.0
    m: 2.0              # Super-Gaussian shape parameter, NOT mass ratio
    basis: uniform
    ...
  species-beam:          # Multiple components can be defined
    v0: 3.0
    T0: 0.2
    ...
```

#### New Structure (what we add under `terms:`):
```yaml
terms:
  species:              # NEW: Define physical species
    - name: electron
      charge: -1.0      # Normalized to electron charge (e)
      mass: 1.0         # Normalized to electron mass (m_e)
      vmax: 6.4         # Velocity grid maximum for this species
      nv: 512           # Number of velocity grid points
      density_components:  # Link to existing density: entries
        - species-background
        - species-beam

    - name: ion
      charge: 10.0      # Example: Z=10 ion
      mass: 1836.0      # Proton mass * 1836 ≈ m_p/m_e
      vmax: 0.15        # Much smaller vmax for ions (thermal velocity scales as √(m_e/m_i))
      nv: 256           # Can use fewer points for colder species
      density_components:
        - species-ion-background

  field: poisson
  edfdv: exponential
  time: sixth
  ...
```

#### Updated Save Configuration:
```yaml
save:
  fields:
    t: {tmin: 0.0, tmax: 100.0, nt: 51}

  electron:             # Can now have multiple species sections
    t: {tmin: 0.0, tmax: 100.0, nt: 51}

  ion:                  # NEW: Save ion distribution
    t: {tmin: 0.0, tmax: 100.0, nt: 11}
```

**Key Design Decisions:**
1. Keep existing `density:` section for defining distribution shapes (backward compatible)
2. New `terms.species` section maps species names to physical parameters (q, m) and density components
3. Each species has its own velocity grid (`vmax`, `nv`) to handle vastly different thermal velocities
4. If `terms.species` is not provided, default to single electron species (backward compatible)
5. Each species can combine multiple density components (e.g., background + beam)

---

### Data Structure Changes

#### Current State Dictionary:
```python
state = {
    "electron": f[nx, nv],     # Single distribution
    "e": e[nx],                # Electric field
    "de": de[nx],              # Field derivative
    "a": a[nx],                # Vector potential
    "da": da[nx],              # Vector potential derivative
    "prev_a": prev_a[nx],      # Previous vector potential
}
```

#### New State Dictionary (Multi-Species):
```python
state = {
    "electron": f_e[nx, nv_e],   # Each species has its own velocity grid size
    "ion": f_i[nx, nv_i],        # Note: nv_e ≠ nv_i in general
    "e": e[nx],                  # Electric field (same for all)
    "de": de[nx],
    "a": a[nx],
    "da": da[nx],
    "prev_a": prev_a[nx],
}
```

**Key Points:**
- Use **flat structure** for backward compatibility (species at top level)
- Each species can have **different velocity grid sizes**: `f_s[nx, nv_s]`
- All species share the same **spatial grid** (nx is same for all)
- Field quantities (e, a, etc.) are shared across all species

---

### Implementation Plan by File

#### 1. `/adept/_vlasov1d/datamodel.py`

**Changes:**
- Add new Pydantic models for species configuration:
  ```python
  class SpeciesConfig(BaseModel):
      name: str
      charge: float
      mass: float
      vmax: float           # Velocity grid maximum
      nv: int               # Number of velocity grid points
      density_components: list[str]

  class VlasovTerms(BaseModel):
      species: list[SpeciesConfig] | None = None  # Default None for backward compat
      field: str
      edfdv: str
      time: str
      fokker_planck: ...
      krook: ...
  ```

**Implementation Notes:**
- Add validation to ensure density components referenced in `species.density_components` exist in `density:` section
- Default `species` to single electron species if not provided:
  ```python
  [SpeciesConfig(
      name="electron",
      charge=-1.0,
      mass=1.0,
      vmax=cfg.grid.vmax,  # Use grid.vmax from config
      nv=cfg.grid.nv,      # Use grid.nv from config
      density_components=list(all_species_keys_from_density)
  )]
  ```
- For backward compatibility, if `grid.vmax` and `grid.nv` are specified (old format), use those for default electron species

---

#### 2. `/adept/_vlasov1d/helpers.py`

**Current Function:**
```python
def _initialize_total_distribution_(cfg, cfg_grid):
    # Returns: (n_prof_total, f[nx, nv])
    # Sums all species-* contributions into single f
```

**New Function:**
```python
def _initialize_distributions_(cfg, cfg_grid):
    """
    Returns: dict[species_name, tuple[n_prof, f[nx, nv]]]

    For each species in cfg.terms.species:
        - Initialize f_s by summing its density_components
        - Compute n_prof_s = ∫f_s dv
    """
    species_dists = {}

    for species in cfg.terms.species:
        f_species = jnp.zeros((cfg_grid["nx"], cfg_grid["nv"]))

        for component_name in species.density_components:
            component_cfg = cfg.density[component_name]
            f_component = _initialize_single_distribution_(component_cfg, cfg_grid)
            f_species += f_component

        n_prof_species = jnp.sum(f_species, axis=1) * cfg_grid["dv"]
        species_dists[species.name] = (n_prof_species, f_species)

    return species_dists
```

**Backward Compatibility:**
- If `cfg.terms.species` is None, default to single electron species
- Keep `_initialize_total_distribution_` as wrapper that calls new function

---

#### 3. `/adept/_vlasov1d/modules.py`

**Changes in `init_state_and_args()` (currently lines 169-193):**

**Current Code:**
```python
def init_state_and_args(self, cfg):
    cfg_grid = cfg["grid"]

    # Initialize single electron distribution
    _, f = _initialize_total_distribution_(cfg, cfg_grid)

    state = {}
    for k in ["electron"]:  # Hardcoded!
        state[k] = f

    state["e"] = ...
    cfg_grid["ion_charge"] = n_prof_total  # Stationary background
    ...
```

**New Code:**
```python
def init_state_and_args(self, cfg):
    cfg_grid = cfg["grid"]

    # Initialize all species distributions
    species_dists = _initialize_distributions_(cfg, cfg_grid)

    state = {}
    for species_name, (n_prof, f_s) in species_dists.items():
        state[species_name] = f_s

    state["e"] = ...

    # Ion charge for quasineutrality (if needed)
    # Only set if single species - multi-species systems self-consistently satisfy quasineutrality
    if len(species_dists) == 1:
        # Single species - need stationary background for quasineutrality
        single_species_name = list(species_dists.keys())[0]
        n_prof, _ = species_dists[single_species_name]
        cfg_grid["ion_charge"] = n_prof
    else:
        # Multi-species - quasineutrality satisfied self-consistently
        cfg_grid["ion_charge"] = jnp.zeros(cfg_grid["nx"])

    return state, cfg_grid
```

**Changes in `write_units()` (lines 24-71):**
- Current normalization uses electron plasma frequency: ω_pe = sqrt(n_0 e² / m_e ε_0)
- **Decision**: Keep electron-based normalization for consistency
- Document that all species q and m are in units of (e, m_e)

---

#### 4. `/adept/_vlasov1d/solvers/pushers/vlasov.py`

**Critical Design Decision**: Each species needs its own velocity grid because ions and electrons have vastly different thermal velocities (differing by factor ~√(m_i/m_e) ≈ 43 for hydrogen). Using the same velocity range would either waste resolution on ions or fail to capture electron physics.

**Architecture**: Pushers will operate on dictionaries of distributions internally, looping over species and applying species-specific grid parameters.

**Changes to `VelocityExponential` (lines 51-58):**

**Current Code:**
```python
class VelocityExponential:
    def __init__(self, v, ...):
        self.v = v
        self.kv_real = jnp.fft.rfftfreq(len(v), d=v[1] - v[0]) * 2 * jnp.pi

    def __call__(self, f, e, dt):
        # Implicitly assumes q/m = -1
        return jnp.real(
            jnp.fft.irfft(
                jnp.exp(-1j * self.kv_real[None, :] * dt * e[:, None])
                * jnp.fft.rfft(f, axis=1),
                axis=1
            )
        )
```

**New Code:**
```python
class VelocityExponential:
    def __init__(self, species_grids, species_params, ...):
        """
        species_grids: dict {species_name: {"v": v_array, "kv": kv_array, ...}}
        species_params: dict {species_name: {"q": q, "m": m, "qm": q/m}}
        """
        self.species_grids = species_grids
        self.species_params = species_params

    def __call__(self, f_dict, e, dt):
        """
        f_dict: dict {species_name: f_s[nx, nv_s]}
        Returns: dict {species_name: f_s'[nx, nv_s]}
        """
        f_new = {}
        for species_name, f_s in f_dict.items():
            kv_s = self.species_grids[species_name]["kv"]
            qm_s = self.species_params[species_name]["qm"]

            f_new[species_name] = jnp.real(
                jnp.fft.irfft(
                    jnp.exp(-1j * kv_s[None, :] * dt * qm_s * e[:, None])
                    * jnp.fft.rfft(f_s, axis=1),
                    axis=1
                )
            )
        return f_new
```

**Changes to `VelocityCubicSpline` (lines 61-68):**

**Current Code:**
```python
class VelocityCubicSpline:
    def __init__(self, v, ...):
        self.v = v
        self.interp = CubicSpline(...)

    def __call__(self, f, e, dt):
        vq = self.v - e[:, None] * dt
        return self.interp(xq=vq, x=self.v, f=f)
```

**New Code:**
```python
class VelocityCubicSpline:
    def __init__(self, species_grids, species_params, ...):
        self.species_grids = species_grids
        self.species_params = species_params
        # Create interpolator for each species with its own v grid
        self.interps = {
            name: CubicSpline(grid["v"], ...)
            for name, grid in species_grids.items()
        }

    def __call__(self, f_dict, e, dt):
        """
        f_dict: dict {species_name: f_s[nx, nv_s]}
        Returns: dict {species_name: f_s'[nx, nv_s]}
        """
        f_new = {}
        for species_name, f_s in f_dict.items():
            v_s = self.species_grids[species_name]["v"]
            qm_s = self.species_params[species_name]["qm"]
            vq = v_s - qm_s * e[:, None] * dt
            f_new[species_name] = self.interps[species_name](xq=vq, x=v_s, f=f_s)
        return f_new
```

**Changes to `SpaceExponential` (lines 71-79):**

**Current Code:**
```python
class SpaceExponential:
    def __init__(self, x, v, ...):
        self.v = v
        self.kx_real = jnp.fft.rfftfreq(len(x), d=x[1] - x[0]) * 2 * jnp.pi

    def __call__(self, f, dt):
        return jnp.real(
            jnp.fft.irfft(
                jnp.exp(-1j * self.kx_real[:, None] * dt * self.v[None, :])
                * jnp.fft.rfft(f, axis=0),
                axis=0
            )
        )
```

**New Code:**
```python
class SpaceExponential:
    def __init__(self, x, species_grids, ...):
        self.kx_real = jnp.fft.rfftfreq(len(x), d=x[1] - x[0]) * 2 * jnp.pi
        self.species_grids = species_grids

    def __call__(self, f_dict, dt):
        """
        f_dict: dict {species_name: f_s[nx, nv_s]}
        Returns: dict {species_name: f_s'[nx, nv_s]}

        Note: Space advection depends on velocity but not on q/m
        """
        f_new = {}
        for species_name, f_s in f_dict.items():
            v_s = self.species_grids[species_name]["v"]
            f_new[species_name] = jnp.real(
                jnp.fft.irfft(
                    jnp.exp(-1j * self.kx_real[:, None] * dt * v_s[None, :])
                    * jnp.fft.rfft(f_s, axis=0),
                    axis=0
                )
            )
        return f_new
```

**Key Points:**
- Each species has its own velocity grid: `v_s`, `kv_s`, `nv_s`, `dv_s`
- Pushers loop internally over species rather than operating on single distributions
- This architecture simplifies the integrator code and ensures consistent handling of species-specific grids

---

#### 5. `/adept/_vlasov1d/solvers/vector_field.py`

This is the **most complex change**. The integrators need to loop over species.

**Changes to `VlasovMaxwell.__init__()` (lines 175-214):**

**Current Code:**
```python
def __init__(self, ..., **kwargs):
    self.cfg_grid = cfg_grid
    # Create single VPFP instance
    self.vpfp = VlasovPoissonFokkerPlanck(...)
    # ...
```

**New Code:**
```python
def __init__(self, ..., species_params, **kwargs):
    self.cfg_grid = cfg_grid
    self.species_params = species_params  # Dict: {name: {"q": q, "m": m, "qm": q/m}}
    self.species_names = list(species_params.keys())

    # Create VPFP instances for each species (or share one? TBD)
    self.vpfp = VlasovPoissonFokkerPlanck(...)
    # ...
```

**Changes to `VlasovMaxwell.__call__()` (lines 216-257):**

**Current Code:**
```python
def __call__(self, t, y, args):
    # y = {"electron": f, "e": e, "a": a, ...}

    # Compute electron density
    electron_density_n = self.compute_charges(y["electron"])

    # Single species step
    e, f, diags = self.vpfp(
        y["electron"], y["a"], args["prev_ex"], dex_array, nu_fp_prof, nu_K_prof
    )

    electron_density_np1 = self.compute_charges(f)

    # Update fields
    # ...

    return {"electron": f, "e": e, ...}
```

**New Code:**
```python
def __call__(self, t, y, args):
    # y = {"electron": f_e, "ion": f_i, "e": e, "a": a, ...}

    # Extract distribution functions for all species
    f_dict = {name: y[name] for name in self.species_names}

    # Step all species forward through Vlasov-Poisson (integrator handles multi-species)
    e, f_new_dict, diags = self.vpfp(
        f_dict, y["a"], args["prev_ex"], dex_array, nu_fp_prof, nu_K_prof
    )

    # Apply Fokker-Planck operator to each species independently
    f_fp_dict = {}
    for species_name in self.species_names:
        f_fp_dict[species_name] = self.fp[species_name](
            nu_fp_prof, nu_K_prof, f_new_dict[species_name], dt=self.dt
        )

    # Update electromagnetic fields
    # ...

    # Construct return state
    state_new = {**f_fp_dict, "e": e, "a": ..., ...}
    return state_new
```

**Changes to `VlasovPoissonFokkerPlanck` (lines 135-172):**

**Current Code:**
```python
def __call__(self, f, a, prev_ex, dex_array, nu_fp_prof, nu_K_prof):
    e, f_vlasov = self.vlasov_poisson(f, a, dex_array, prev_ex)
    f_fp = self.fp(nu_fp, nu_K, f_vlasov, dt=self.dt)
    return e, f_fp, diags
```

**New Code:**
```python
def __call__(self, f_dict, a, prev_ex, dex_array, nu_fp_prof, nu_K_prof):
    """
    f_dict: dict {species_name: f_s[nx, nv_s]}
    Returns: e[nx], f_dict_new, diags

    Note: Integrator handles multi-species internally
    """
    # Vlasov-Poisson step (integrator loops over species, synchronizes field solve)
    e, f_vlasov_dict = self.vlasov_poisson(f_dict, a, dex_array, prev_ex)

    # Fokker-Planck is handled at higher level (VlasovMaxwell)
    # because it's applied independently to each species

    return e, f_vlasov_dict, diags
```

**Changes to Integrators (LeapfrogIntegrator, SixthOrderHamIntegrator):**

Since pushers now operate on dicts internally, the integrators become much cleaner. They receive and return dicts of distributions.

**LeapfrogIntegrator:**

**Current Code:**
```python
def __call__(self, f, e_fields, prev_ex):
    f = self.edfdv(f, e_fields, 0.5 * self.dt)
    f = self.vdfdx(f, self.dt)
    e = self.field_solver(f, prev_ex, e_fields)
    f = self.edfdv(f, e, 0.5 * self.dt)
    return e, f
```

**New Code:**
```python
def __call__(self, f_dict, e_fields, prev_ex):
    """
    f_dict: dict {species_name: f_s[nx, nv_s]}
    Returns: e[nx], f_dict_new
    """
    # First half-step in velocity (pushers handle dict internally)
    f_dict = self.edfdv(f_dict, e_fields, 0.5 * self.dt)

    # Full step in space
    f_dict = self.vdfdx(f_dict, self.dt)

    # Solve field from total charge density
    e = self.field_solver(f_dict, prev_ex, e_fields)

    # Second half-step in velocity
    f_dict = self.edfdv(f_dict, e, 0.5 * self.dt)

    return e, f_dict
```

**SixthOrderHamIntegrator:**

The structure is similar but with multiple substeps. Since pushers handle the dict iteration, the integrator code remains clean:

```python
def __call__(self, f_dict, e_fields, prev_ex):
    """
    6th-order symplectic integrator for multi-species Vlasov-Poisson
    """
    # Coefficients for 6th order method
    c = [0.0378593198406116, 0.102635633102435, ...]
    d = [0.0792036964311957, 0.209515106613362, ...]

    # Initial velocity half-step
    f_dict = self.edfdv(f_dict, e_fields, c[0] * self.dt)

    # Main loop over substeps
    for i in range(len(d)):
        f_dict = self.vdfdx(f_dict, d[i] * self.dt)
        e = self.field_solver(f_dict, prev_ex, e_fields) if i < len(d)-1 else e
        f_dict = self.edfdv(f_dict, e, c[i+1] * self.dt)

    return e, f_dict
```

**Key Points:**
- Integrators operate on `f_dict` throughout
- Pushers (`edfdv`, `vdfdx`) handle species iteration internally
- Field solver receives `f_dict` and computes total charge density internally
- This architecture keeps integrator code clean even for complex schemes

---

#### 6. `/adept/_vlasov1d/solvers/pushers/field.py`

**Architecture Decision**: Field solvers receive `f_dict` and compute total charge/current density internally. This is consistent with the pusher architecture and keeps the integrator clean.

**Changes to `SpectralPoissonSolver` (lines 100-139):**

**Current Code:**
```python
class SpectralPoissonSolver:
    def __init__(self, kx, ...):
        self.kx = kx
        # ...

    def __call__(self, f, dex_array, prev_ex):
        charge_density = self.compute_charges(f)  # Assumes f is electron dist
        e = self.poisson(charge_density)
        return e

    def compute_charges(self, f):
        # ∫f dv
        return jnp.sum(f, axis=1) * self.dv
```

**New Code:**
```python
class SpectralPoissonSolver:
    def __init__(self, kx, species_grids, species_params, ...):
        self.kx = kx
        self.species_grids = species_grids
        self.species_params = species_params
        # ...

    def __call__(self, f_dict, dex_array, prev_ex):
        """
        f_dict: dict {species_name: f_s[nx, nv_s]}
        Returns: e[nx]
        """
        # Compute total charge density: ρ = Σ_s q_s ∫f_s dv_s
        charge_density = jnp.zeros(self.nx)
        for species_name, f_s in f_dict.items():
            q = self.species_params[species_name]["q"]
            dv_s = self.species_grids[species_name]["dv"]
            n_s = jnp.sum(f_s, axis=1) * dv_s  # ∫f_s dv_s
            charge_density += q * n_s

        # Solve Poisson equation: ∂E/∂x = ρ
        e = self.poisson(charge_density)
        return e
```

**Changes to `AmpereSolver` and `HampereSolver`:**

Similar structure - receive `f_dict`, compute total current density `j_y = Σ_s (q_s/m_s) ∫v_y f_s dv`:

```python
class AmpereSolver:
    def __init__(self, ..., species_grids, species_params):
        self.species_grids = species_grids
        self.species_params = species_params
        # ...

    def __call__(self, f_dict, ...):
        # Compute total current density
        current_density = jnp.zeros(self.nx)
        for species_name, f_s in f_dict.items():
            q = self.species_params[species_name]["q"]
            m = self.species_params[species_name]["m"]
            # For 1D: j_y comes from vy component (would need 2D distribution for this)
            # This might require extending to 1D2V
            pass

        # Solve Ampere equation
        # ...
```

**Note**: Current 1D1V implementation may need extension to 1D2V for proper current calculation in Maxwell solvers.

---

#### 7. `/adept/_vlasov1d/storage.py`

**Changes to `store_f()` (line 69):**

**Current Code:**
```python
def store_f(state, t, args, save_func):
    for species in ["electron"]:  # Hardcoded!
        save_func(f"f_{species}", state[species], t)
```

**New Code:**
```python
def store_f(state, t, args, save_func, species_names):
    for species in species_names:
        if species in state:  # Check species exists in state
            save_func(f"f_{species}", state[species], t)
```

**Changes to `get_dist_save_func()` (line 95):**
- Read species list from config: `cfg["terms"]["species"]`
- Create save functions for each species in config

**Changes to `BaseVlasov1D.save()` in `modules.py`:**
- Pass `species_names` to storage functions
- Update NetCDF variable names to include species

---

### Architecture Decision: Integrator Restructuring

**Problem**: The current integrator structure is:
```
LeapfrogIntegrator:
    edfdv(f, e) -> f'
    vdfdx(f') -> f''
    field_solver(f'') -> e'
    edfdv(f'', e') -> f'''
```

With multiple species, we need:
```
For each species s:
    edfdv(f_s, e, qm_s) -> f_s'
    vdfdx(f_s') -> f_s''

field_solver(Σ_s q_s * ∫f_s'' dv) -> e'

For each species s:
    edfdv(f_s'', e', qm_s) -> f_s'''
```

**Solution Options:**

**Option A**: Integrators receive and return **dictionaries** of distributions:
```python
class LeapfrogIntegrator:
    def __call__(self, f_dict, species_params, ...):
        # First half-step for all species
        f_half = {}
        for name, f_s in f_dict.items():
            qm = species_params[name]["qm"]
            f_half[name] = self.edfdv(f_s, e, 0.5*dt, qm)

        # Full space step for all species
        f_full = {}
        for name, f_s in f_half.items():
            f_full[name] = self.vdfdx(f_s, dt)

        # Compute total charge density
        charge_density = sum(q * compute_charges(f_s)
                            for (name, f_s), q in zip(f_full.items(), ...))

        # Solve field (once for all species)
        e_new = self.field_solver(charge_density, ...)

        # Second half-step for all species
        f_new = {}
        for name, f_s in f_full.items():
            qm = species_params[name]["qm"]
            f_new[name] = self.edfdv(f_s, e_new, 0.5*dt, qm)

        return e_new, f_new
```

**Option B**: Keep integrators operating on single distributions, do multi-species loop at higher level:
- Pro: Less invasive changes to integrators
- Con: Can't properly synchronize field solve across species

**Recommendation**: **Option A** - Integrators should handle multi-species explicitly. This ensures proper synchronization of field solves and is more physics-correct. The integrators must accept a dict of species to ensure mathematically correct coupling through the field equations.

---

### Implementation Phases

#### Phase 1: Configuration and Data Model (Foundation)
**Files**: `datamodel.py`, test configs
- Add `SpeciesConfig` Pydantic model
- Update `VlasovTerms` to include `species` field
- Add validation logic
- Create test configuration files with 2 species
- **Success Criteria**: Config files parse correctly with new schema

#### Phase 2: Initialization (Data Structures)
**Files**: `helpers.py`, `modules.py`
- Modify `_initialize_distributions_()` to return dict of distributions
- Update `init_state_and_args()` to handle multiple species
- Update state dictionary structure
- **Success Criteria**: Multi-species state initializes correctly

#### Phase 3: Pushers (Core Physics)
**Files**: `pushers/vlasov.py`
- Add `qm_ratio` parameter to `VelocityExponential` and `VelocityCubicSpline`
- Update tests for pushers
- **Success Criteria**: Pushers work with arbitrary q/m ratios

#### Phase 4: Field Solvers (Charge/Current Density)
**Files**: `pushers/field.py`
- Modify field solvers to accept total charge density
- Update current density calculations for Maxwell solvers
- **Success Criteria**: Field solvers handle multi-species charge densities

#### Phase 5: Integrators (Orchestration)
**Files**: `vector_field.py` (LeapfrogIntegrator, SixthOrderHamIntegrator)
- Restructure integrators to handle dict of distributions
- Thread `qm_ratio` through all substeps
- Synchronize field solves across species
- **Success Criteria**: Time integration works for 2+ species

#### Phase 6: Top-Level Solver (Coordination)
**Files**: `vector_field.py` (VlasovPoissonFokkerPlanck, VlasovMaxwell)
- Update `VlasovMaxwell.__call__()` to loop over species
- Update `VlasovPoissonFokkerPlanck` to pass through species params
- **Success Criteria**: Full solver runs multi-species simulations

#### Phase 7: Storage and Diagnostics
**Files**: `storage.py`, `modules.py`
- Update NetCDF storage to handle multiple species
- Generalize `store_f()` and `get_dist_save_func()`
- Update diagnostics
- **Success Criteria**: Multi-species results save/load correctly

#### Phase 8: Testing and Validation
**Files**: `tests/`, new test configs
- Unit tests for each modified component
- Integration test: Two-stream instability (2 electron populations - should match current results)
- Integration test: Ion acoustic wave (electron + ion)
- Integration test: Landau damping with mobile ions
- **Success Criteria**: All tests pass, physics results validated

#### Phase 9: Documentation
**Files**: Documentation, example configs
- Document new configuration schema
- Provide example multi-species configs
- Update API documentation
- **Success Criteria**: Users can run multi-species simulations from docs

---

### Backward Compatibility Strategy

**Goal**: Existing configs should work without modification.

**Implementation**:
1. **Default species list**: If `terms.species` is not provided:
   ```python
   default_species = [
       SpeciesConfig(
           name="electron",
           charge=-1.0,
           mass=1.0,
           density_components=list(all_density_keys_starting_with_species)
       )
   ]
   ```

2. **State dictionary**: Keep species at top level (not nested under `"distributions"`)
   - Old: `state["electron"]` ✓ (still works)
   - New: `state["electron"]`, `state["ion"]` ✓

3. **Save configuration**: If `save.electron` is specified but `save.ion` is not, only save electron
   - Existing configs will only have `save.electron` ✓

4. **Pusher signatures**: Use `qm_ratio=-1.0` as default parameter
   ```python
   def __call__(self, f, e, dt, qm_ratio=-1.0):  # Default to electron
   ```

---

### Testing Strategy

#### Unit Tests

**Test: Pusher q/m scaling**
- `VelocityExponential` with qm_ratio=2.0 should shift velocities twice as much
- Verify: `edfdv(f, e, dt, qm=2.0)` ≈ `edfdv(f, 2*e, dt, qm=1.0)`

**Test: Charge density summation**
- Two distributions with q=-1, q=+1 should cancel if equal densities
- Verify: `_compute_total_charge_density({e: f, i: f})` ≈ 0

**Test: Configuration parsing**
- New schema with `terms.species` parses correctly
- Old schema without `terms.species` uses default electron species
- Validation catches missing density components

#### Integration Tests

**Test 1: Two-stream instability (multi-component electrons)**
- Config: Two counter-streaming electron beams (like existing twostream.yaml)
- Compare results with/without multi-species implementation
- **Expected**: Identical results (validates backward compatibility)

**Test 2: Stationary ions (single mobile electron species)**
- Config: Electrons + stationary heavy ions (m_i/m_e = 1836, v0_i=0)
- Run Vlasov-Poisson with only electrons evolving
- **Expected**: Should match single-species electron results

**Test 3: Ion acoustic wave (mobile electron + ion)**
- Config: Cold ions + hot electrons, sinusoidal perturbation
- **Expected**: Oscillation at ion acoustic frequency ω_ia ≈ k·c_s, where c_s = sqrt(T_e/m_i)
- Validate: Measure oscillation frequency from E field time series

**Test 4: Landau damping with ions**
- Config: Maxwellian electrons + ions, density perturbation
- **Expected**: Damping rate should differ from electron-only case
- Validate: Compare damping rate γ vs theory

**Test 5: Electron-ion two-stream**
- Config: Drifting electrons + drifting ions
- **Expected**: Two-stream instability growth rate depends on both species
- Validate: Growth rate vs theory

---

### Open Questions / Decisions Needed

1. **Fokker-Planck collisions**:
   - Current implementation: Intra-species collisions (electron-electron)
   - Multi-species: Need electron-ion collisions?
   - **Decision**: Phase 1 will only support intra-species collisions (apply FP operator to each species independently)
   - **Future**: Add inter-species collision operators if needed

2. **Normalization**:
   - Keep electron-based normalization (ω_pe, v_te)?
   - Or allow species-dependent normalization?
   - **Decision**: Keep electron-based normalization for simplicity. All q, m in units of (e, m_e).

3. **Quasineutrality**:
   - Currently: `cfg_grid["ion_charge"]` is set to electron density (stationary background)
   - Multi-species: Do we still need a stationary background?
   - **Decision**:
     - If `density.quasineutrality: true`, compute background from: `n_bg = sum(q_s * n_s)` over all species
     - This background is used for initial Poisson solve only
     - Set `cfg_grid["ion_charge"] = n_bg` for compatibility

4. **State dictionary structure**:
   - Flat: `state = {"electron": f_e, "ion": f_i, "e": e, ...}` ✓ (Recommended)
   - Nested: `state = {"distributions": {"electron": f_e, "ion": f_i}, "e": e, ...}`
   - **Decision**: Use flat structure for backward compatibility

5. **Maxwell solver current density**:
   - Need to compute j = Σ_s (q_s/m_s) ∫v·f_s dv
   - Where should this summation happen?
   - **Decision**: In integrator before calling field solver, similar to charge density

---

### Summary

This plan provides a comprehensive roadmap for adding multi-species support to the _vlasov1d module. The key changes are:

1. **Configuration**: Add `terms.species` list with q, m parameters
2. **Data structures**: Replace single `f` with dict `{name: f_s}`
3. **Pushers**: Add `qm_ratio` parameter to velocity advection
4. **Field solvers**: Accept total charge/current density from all species
5. **Integrators**: Loop over species for advection, synchronize field solves
6. **Storage**: Generalize to save multiple species

The implementation is designed to maintain backward compatibility while enabling rich multi-species physics including electron-ion interactions.
